<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The OmniPaxos Book</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A User Guide, Manual, and Tutorial for the OmniPaxos library.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
                <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="getting-started.html">Getting Started</a></li><li class="chapter-item expanded "><a href="introduction/index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="sequencepaxos/index.html"><strong aria-hidden="true">2.</strong> SequencePaxos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="sequencepaxos/communication.html"><strong aria-hidden="true">2.1.</strong> Communication</a></li><li class="chapter-item expanded "><a href="sequencepaxos/log.html"><strong aria-hidden="true">2.2.</strong> Reading and Writing</a></li><li class="chapter-item expanded "><a href="sequencepaxos/compaction.html"><strong aria-hidden="true">2.3.</strong> Compaction</a></li><li class="chapter-item expanded "><a href="sequencepaxos/reconfiguration.html"><strong aria-hidden="true">2.4.</strong> Reconfiguration</a></li><li class="chapter-item expanded "><a href="sequencepaxos/logging.html"><strong aria-hidden="true">2.5.</strong> Logging</a></li></ol></li><li class="chapter-item expanded "><a href="ble/index.html"><strong aria-hidden="true">3.</strong> Ballot Leader Election</a></li><li class="chapter-item expanded "><a href="runtime/index.html"><strong aria-hidden="true">4.</strong> Runtime</a></li><li class="chapter-item expanded affix "><a href="project.html">Project Info</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">The OmniPaxos Book</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/haraldng/omnipaxos" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="foreword"><a class="header" href="#foreword">Foreword</a></h1>
<p>OmniPaxos is an in-development replicated log library implemented in Rust. OmniPaxos aims to hide the complexities of consensus to provide users a replicated log that is as simple to use as a local log. </p>
<p>Similar to Raft, OmniPaxos can be used to build strongly consistent services such as replicated state machines. Additionally, the leader election of OmniPaxos offers better resilience to partial connectivity and more flexible and efficient reconfiguration compared to Raft.</p>
<p>The library consist of two parts: <code>omnipaxos_core</code> and <code>omnipaxos_runtime</code>. The <code>omnipaxos_core</code> implements the algorithms of OmniPaxos as plain Rust structs and is suitable for integration with systems that already have an async runtime or are implemented in an actor framework. It requires users to implement the interaction between the different structs themselves as we describe <a href="ble/index.html">here</a>. If you just want a replicated log out of the box, we suggest using <code>omnipaxos_runtime</code> instead, which hides all the interactions from the user by using <a href="https://tokio.rs/">Tokio</a>.</p>
<p>All the code from the tutorial can be found in <a href="https://github.com/haraldng/omnipaxos/tree/master/examples">examples</a>. In addition to the tutorial style presentation in this book, examples of usages of OmniPaxos can be found in the <a href="https://github.com/haraldng/omnipaxos/tree/master/tests">tests</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>We aim to make a release on crates soon, but for now, the easiest way to use OmniPaxos is to have it as a GitHub dependency.</p>
<!-- ## Setting up Rust
It is recommended to run OmniPaxos on a *nightly* version of the Rust toolchain.

We recommend using the [rustup](https://rustup.rs/) tool to easily install the latest nightly version of rust and keep it updated. Instructions should be on the screen once rustup is downloaded.

> **Using the nightly toolchain:** Rustup can be configured to default to the nightly toolchain by running `rustup default nightly`. 

## Cargo

Add OmniPaxos to your cargo project as a dependency:

```toml
[dependencies]
omnipaxos = "LATEST_VERSION"
``` 
The latest version can be found on [crates.io](https://crates.io/crates/omnipaxos). -->
<h3 id="github-master"><a class="header" href="#github-master">Github master</a></h3>
<!--You can also point cargo to the latest [Github](https://github.com/haraldng/omnipaxos) master version, instead of a release.  -->
<p>To do so add the following to your Cargo.toml:</p>
<pre><code class="language-toml">[dependencies]
omnipaxos = { git = &quot;https://github.com/haraldng/omnipaxos&quot; }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>The OmniPaxos library is mainly driven by the <a href="introduction/../sequencepaxos/index.html"><strong>SequencePaxos</strong></a> and <a href="introduction/../ble/index.html"><strong>Ballot Leader Election</strong></a> (<em>BLE</em>) structs.  These are plain Rust structs and the user therefore needs to provide a network implementation themselves to actually send and receive messages. In this tutorial we will show how a user should interact with these structs in order to implement a strongly consistent, replicated log. This tutorial will focus on how to use the library and showcase its features. </p>
<!-- For the properties and advantages of OmniPaxos in comparison to other similar protocols, we refer to the Omni-Paxos paper. --><div style="break-before: page; page-break-before: always;"></div><h1 id="sequencepaxos"><a class="header" href="#sequencepaxos">SequencePaxos</a></h1>
<p>Each server in the cluster should have a local instance of the  <code>SequencePaxos</code> struct. <code>SequencePaxos</code> maintains a local state of the replicated log, handles incoming messages and produces outgoing messages that the user has to fetch and send using their network implementation. The users also accesses the replicated log via <code>SequencePaxos</code>.</p>
<h2 id="example-key-value-store"><a class="header" href="#example-key-value-store">Example: Key-Value store</a></h2>
<p>As a guide for this tutorial, we will use OmniPaxos to implement a replicated log for the purpose of a consistent Key-Value store. </p>
<p>We begin by defining the type that we want our log entries to consist of:</p>
<pre><code class="language-rust edition2018 no_run noplaypen">#[derive(Clone, Debug)] // Clone and Debug are required traits.
pub struct KeyValue {
    pub key: String,
    pub value: u64,
}
</code></pre>
<h2 id="storage"><a class="header" href="#storage">Storage</a></h2>
<p>You are free to use any storage implementation with <code>SequencePaxos</code>. The only requirement is that it implements the <code>Storage</code> trait. OmniPaxos provides an in-memory storage implementation <code>MemoryStorage</code> which we will use in our example.
For simplicity, we leave out some parts of the implementation for now (such as <a href="sequencepaxos/../compaction.html">Snapshots</a>).</p>
<pre><code class="language-rust edition2018 no_run noplaypen">    // from the module storage::memory_storage
    #[derive(Clone)]
    pub struct MemoryStorage&lt;T, S&gt;
    where
        T: Entry,
        S: Snapshot&lt;T&gt;,
    {
        /// Vector which contains all the replicated entries in-memory.
        log: Vec&lt;T&gt;,
        /// Last promised round.
        n_prom: Ballot,
        /// Last accepted round.
        acc_round: Ballot,
        /// Length of the decided log.
        ld: u64,
        ...
    }

    impl&lt;T, S&gt; Storage&lt;T, S&gt; for MemoryStorage&lt;T, S&gt;
    where
        T: Entry,
        S: Snapshot&lt;T&gt;,
    {
        fn append_entry(&amp;mut self, entry: T) -&gt; u64 {
            self.log.push(entry);
            self.get_log_len()
        }

        fn append_entries(&amp;mut self, entries: Vec&lt;T&gt;) -&gt; u64 {
            let mut e = entries;
            self.log.append(&amp;mut e);
            self.get_log_len()
        }

        fn append_on_prefix(&amp;mut self, from_idx: u64, entries: Vec&lt;T&gt;) -&gt; u64 {
            self.log.truncate(from_idx as usize);
            self.append_entries(entries)
        }

        fn set_promise(&amp;mut self, n_prom: Ballot) {
            self.n_prom = n_prom;
        }

        fn set_decided_idx(&amp;mut self, ld: u64) {
            self.ld = ld;
        }

        fn get_decided_idx(&amp;self) -&gt; u64 {
            self.ld
        }

        fn set_accepted_round(&amp;mut self, na: Ballot) {
            self.acc_round = na;
        }

        fn get_accepted_round(&amp;self) -&gt; Ballot {
            self.acc_round
        }

        fn get_entries(&amp;self, from: u64, to: u64) -&gt; &amp;[T] {
            self.log.get(from as usize..to as usize).unwrap_or(&amp;[])
        }

        fn get_log_len(&amp;self) -&gt; u64 {
            self.log.len() as u64
        }

        fn get_suffix(&amp;self, from: u64) -&gt; &amp;[T] {
            match self.log.get(from as usize..) {
                Some(s) =&gt; s,
                None =&gt; &amp;[],
            }
        }

        fn get_promise(&amp;self) -&gt; Ballot {
            self.n_prom
        }
        
        ...
    }
</code></pre>
<h2 id="creating-a-node"><a class="header" href="#creating-a-node">Creating a Node</a></h2>
<p>With the structs for log entry and storage defined, we can now go ahead and create our <code>SequencePaxos</code> replica instance.  Let’s assume we want our KV-store to be replicated on three servers. On, say node 2, we would do the following: </p>
<pre><code class="language-rust edition2018 no_run noplaypen">use omnipaxos_core::{
    sequence_paxos::{SequencePaxos, SequencePaxosConfig},
    storage::{memory_storage::MemoryStorage},
};

// configuration with id 1 and the following cluster
let configuration_id = 1;
let _cluster = vec![1, 2, 3];

// create the replica 2 in this cluster (other replica instances are created similarly with pid 1 and 3 on the other nodes)
let my_pid = 2;
let my_peers = vec![1, 3];

let mut sp_config = SequencePaxosConfig::default();
sp_config.set_configuration_id(configuration_id);
sp_config.set_pid(my_pid);
sp_config.set_peers(my_peers);

let storage = MemoryStorage::&lt;KeyValue, ())&gt;::default();
let mut sp = SequencePaxos::with(sp_config, storage);
</code></pre>
<p>For convenience, <code>SequencePaxosConfig</code> also features a constructor <code>SequencePaxosConfig::with_hocon()</code> that loads the values using <a href="https://vleue.com/hocon.rs/hocon/index.html">hocon</a>. One could then instead have the parameters in a file <code>config/node2.conf</code></p>
<pre><code class="language-json">{
    config_id: 1,
    pid: 2,
    log_file_path: &quot;/sequencepaxos/logs&quot;
}
</code></pre>
<p>This can then be loaded to construct <code>SequencePaxosConfig</code>:</p>
<pre><code class="language-rust edition2018 no_run noplaypen">let raw_cfg = HoconLoader::new()
    .load_file(&quot;tests/config/node2.conf&quot;)
    .expect(&quot;Failed to load hocon file&quot;)
    .hocon()
    .unwrap();

let sp_config = SequencePaxosConfig::with_hocon(cfg);
</code></pre>
<h2 id="crash-recovery"><a class="header" href="#crash-recovery">Crash-recovery</a></h2>
<p>To support crash-recovery, we have to make sure that our storage implementation persisted the values. Then upon recovery, we have to make sure that our <code>SequencePaxos</code> will be started with the previously persisted state. To do so, create <code>SequencePaxos</code> as earlier described but use the persisted state as the <code>storage</code> argument. Then, call <code>fail_recovery()</code> to correctly initialize the volatile state.</p>
<pre><code class="language-rust edition2018 no_run noplaypen">/* Restarting our node after a crash... */
let recovered_storage = ...;    // the recovered persistent state.
let mut recovered_paxos = SequencePaxos::with(sp_config, recovered_storage);
recovered_paxos.fail_recovery();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="communication"><a class="header" href="#communication">Communication</a></h1>
<p>As previously mentioned, the user has to send/receive messages between servers themselves. In this section, we show how the user should interact with <code>SequencePaxos</code> and its incoming and outgoing messages.</p>
<h2 id="incoming-and-outgoing"><a class="header" href="#incoming-and-outgoing">Incoming and Outgoing</a></h2>
<p>When a message is received from the network layer intended for our node, we need to handle it in <code>SequencePaxos</code>.</p>
<pre><code class="language-rust edition2018 no_run noplaypen">use omnipaxos_core::messages::Message;

// handle incoming message from network layer
let msg: Message&lt;KeyValue, KVSnapshot&gt; = ...;    // message to this node e.g. `msg.to = 2`
seq_paxos.handle(msg);
</code></pre>
<p>By handling incoming messages and local calls such as <code>append()</code>, our local <code>seq_paxos</code> will produce outgoing messages for its peers. Thus, we must periodically send the outgoing messages on the network layer.</p>
<pre><code class="language-rust edition2018 no_run noplaypen">// send outgoing messages. This should be called periodically, e.g. every ms
for out_msg in seq_paxos.get_outgoings_msgs() {
    let receiver = out_msg.to;
    // send out_msg to receiver on network layer
}
</code></pre>
<blockquote>
<p><strong>Note:</strong> The networking i.e. how to actually send and receive messages needs to be implemented by you, the user. Similarly, you have to periodically fetch these outgoing messages from <code>SequencePaxos</code>. </p>
</blockquote>
<h2 id="handling-disconnections"><a class="header" href="#handling-disconnections">Handling Disconnections</a></h2>
<p>One of the main advantages of Omni-Paxos is its resilience to partial connectivity. If one node loses connection to another and then reconnects (e.g. after a TCP-session drop), make sure to call <code>reconnected(pid)</code> before handling any incoming messages from that peer.</p>
<pre><code class="language-rust edition2018 no_run noplaypen">// network layer notifies of reconnecting to peer with pid = 3
seq_paxos.reconnected(3);
...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reading-and-writing"><a class="header" href="#reading-and-writing">Reading and Writing</a></h1>
<p>We now show how to read and write the replicated log. The replicated log is <em>append-only</em>. To append an entry we call the following:</p>
<pre><code class="language-rust edition2018 no_run noplaypen">let write_entry = KeyValue { key: String::from(&quot;a&quot;), value: 123 };

seq_paxos.append(write_entry).expect(&quot;Failed to append&quot;);
</code></pre>
<p>This will cause our <code>write_entry</code> to be proposed to get decided in the replicated log. Appends can be pipelined without waiting for preceding entries to be decided. Furthermore, <code>append()</code> can be called on any node. If the calling node is not the leader, the entry will be forwarded. </p>
<h2 id="reading-the-log"><a class="header" href="#reading-the-log">Reading the Log</a></h2>
<p>Reads are also handled by calling various functions on <code>SequencePaxos</code>. To read the entry at a specific index <code>idx</code> of the log we call <code>seq_paxos.read_entry(idx)</code>. We can also read a specific range of log entries with <code>seq_paxos.read_entries()</code>. </p>
<pre><code class="language-rust edition2018 no_run noplaypen">/*** Read a single entry ***/
let idx = 5;
let read_entry = seq_paxos.read(idx);

/*** Read a range ***/
let read_entries = seq_paxos.read_entries(2..5);
</code></pre>
<p>The read functions return <code>Option&lt;LogEntry&gt;</code> and <code>Option&lt;Vec&lt;LogEntry&gt;&gt;</code> respectively, where <code>None</code> is returned if the index or range is out of bounds. <code>LogEntry</code> is an enum with the following variants:</p>
<ul>
<li><code>Decided(&amp;T)</code>: The entry is decided and guaranteed to not be reverted. It is thus safe to apply a decided entry to the application state. For instance, in our case, it is safe to update our key-value store when we read a <code>Decided(&amp;KeyValue)</code> entry.</li>
<li><code>Undecided(&amp;T)</code>: The entry is NOT decided and might be removed from the log at a later time. However, it could be useful in applications that allow speculative execution for example.</li>
<li><code>Trimmed(TrimmedIndex)</code>: We tried to read an index where the entry has already been trimmed. </li>
<li><code>Snapshotted(SnapshottedEntry&lt;T, S&gt;)</code>: The index we read has already been compacted into a snapshot. We can access the snapshot from the field <code>snapshot</code> in <code>SnapshottedEntry</code>. In our case our this will correspond to <code>KVSnapshot</code> that we defined <a href="sequencepaxos/../compaction.html">here</a>.</li>
<li><code>StopSign(StopSign)</code>: This Sequence Paxos instance has been stopped for reconfiguration. This implies that this log will not be appended anymore and one should use the new Sequence Paxos instead for writing.</li>
</ul>
<p>It is also possible to only read decided entries or snapshot from a specific index using <code>read_decided_suffix(idx)</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compaction"><a class="header" href="#compaction">Compaction</a></h1>
<p>As time passes, the replicated log in <code>SequencePaxos</code> will grow large. To avoid letting the log growing infinitely large, we support two ways of compaction that can be initiated by users:</p>
<h2 id="trim"><a class="header" href="#trim">Trim</a></h2>
<p>Trimming the log removes all entries up to a certain index. Since the entries are deleted from the log, a trim operation can only be done if <strong>ALL</strong> nodes in the cluster have decided up to that index. Example:</p>
<pre><code class="language-rust edition2018 no_run noplaypen">use omnipaxos_core::sequence_paxos::CompactionErr;

// we will try trimming the first 100 entries of the log.
let trim_idx = Some(100);  // using `None` will use the highest trimmable index
match seq_paxos.trim(trim_idx) {
    Ok(_) =&gt; {
        // later, we can see that the trim succeeded with `seq_paxos.get_compacted_idx()`
    }
    Err(e) =&gt; {
        match e {
            CompactionErr::NotAllDecided(idx) =&gt; {
                // Our provided trim index was not decided by all servers yet. All servers have currently only decided up to `idx`.
                // If desired, users can retry with seq_paxos.trim(Some(idx)) which will then succeed.
            }
            ...
        }
    }
}
</code></pre>
<blockquote>
<p><strong>Note:</strong> Make sure your application really does not need the data that will be trimmed anymore. Once it is succeeded, the trimmed entries are lost and cannot be read or recovered.</p>
</blockquote>
<h2 id="snapshot"><a class="header" href="#snapshot">Snapshot</a></h2>
<p>The disadvantage of trimming is that the data is lost after the trim and it requires all servers to have decided the trim index. If the entries in the log are such that they can be compacted into a snapshot, <code>SequencePaxos</code> supports snapshotting decided entries of the log. For instance, in our kv-store example application, we don’t need to keep every log entry that changes the kv-pairs. Instead, if we want to snapshot the log, it is sufficient to keep the latest value for every key. We implement our snapshot as a struct called <code>KVSnapshot</code> which is just a wrapper for a <code>HashMap</code> that will hold the latest value for every key in the log. To make it work with <code>SequencePaxos</code>, we need to implement the trait <code>Snapshot</code> for <code>KVSnapshot</code>:</p>
<pre><code class="language-rust edition2018 no_run noplaypen">use omnipaxos_core::storage::Snapshot;

#[derive(Clone, Debug)]
pub struct KVSnapshot {
    snapshotted: HashMap&lt;String, u64&gt;
}

impl Snapshot&lt;KeyValue&gt; for KVSnapshot {
    fn create(entries: &amp;[KeyValue]) -&gt; Self {
        let mut snapshotted = HashMap::new();
        for e in entries {
            let KeyValue { key, value } = e;
            snapshotted.insert(key.clone(), *value);
        }
        Self { snapshotted }
    }

    fn merge(&amp;mut self, delta: Self) {
        for (k, v) in delta.snapshotted {
            self.snapshotted.insert(k, v);
        }
    }

    fn use_snapshots() -&gt; bool {
        true
    }
}
</code></pre>
<p>The <code>create_entries()</code> function tells <code>SequencePaxos</code> how to create a snapshot given a slice of entries of our <code>KeyValue</code> type. In our case, we simply want to insert the kv-pair into the hashmap. The <code>merge()</code> function defines how we can merge two snapshots. In our case, we will just insert/update the kv-pairs from the other snapshot. The <code>use_snapshots()</code> function simply tells <code>SequencePaxos</code> if snapshots should be used in the protocol. This is needed for users that does not want to use snapshots.</p>
<p>With <code>KVSnapshot</code>, we would have instead created our <code>SequencePaxos</code> node as follows:</p>
<pre><code class="language-rust edition2018 no_run noplaypen">// ...same as shown before in the `SequencePaxos` chapter.
let storage = MemoryStorage::&lt;KeyValue, KVSnapshot)&gt;::default();    // use KVSnapshot as type argument instead of ()
let mut sp = SequencePaxos::with(sp_config, storage);
</code></pre>
<p>We can now create snapshots and read snapshots from <code>SequencePaxos</code>. Furthermore, snapshotting allows us to either just do the snapshot locally or request all nodes in the cluster to do it with the boolean parameter <code>local_only</code>.</p>
<pre><code class="language-rust edition2018 no_run noplaypen">// we will try snapshotting the first 100 entries of the log.
let snapshot_idx = Some(100);  // using `None` will use the highest snapshottable index
let local_only = false; // snapshots will be taken by all nodes.
match seq_paxos.trim(snapshot_idx, local_only) {
    Ok(_) =&gt; {
        // later, we can see that the snapshot succeeded with `seq_paxos.get_compacted_idx()`
    }
    Err(e) =&gt; {
        match e {
            CompactionErr::UndecidedIndex(idx) =&gt; {
                // Our provided snapshot index is not decided yet. The currently decided index is `idx`.
            }
            ...
        }
    }
}

// reading a snapshotted entry
if let Some(e) = seq_paxos.read(20) {
    match e {
        LogEntry::Snapshotted(s) =&gt; {
            // entry at idx 20 is snapshotted since we snapshotted idx 100
            let snapshotted_idx = s.trimmed_idx;
            let snapshot: KVSnapshot = s.snapshot;
            // ...can query the latest value for a key in snapshot
        }
        ...
}
</code></pre>
<blockquote>
<p><strong>Note:</strong> If your <code>Entry</code> type is not snapshottable, simply use <code>()</code> as type argument for <code>Snapshot</code>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reconfiguration"><a class="header" href="#reconfiguration">Reconfiguration</a></h1>
<p>To change the nodes in the cluster, we must first stop the current Sequence Paxos instance. This is done via the <code>reconfigure()</code> function, which has a <code>ReconfigurationRequest</code> that contains the nodes for the next Sequence Paxos instance and some optional metadata.</p>
<pre><code class="language-rust edition2018 no_run noplaypen">// Node 3 seems to have crashed... let's replace it with a new node 4.
let new_configuration = vec![1, 2, 4];
let metadata = None;
let rc = ReconfigurationRequest::with(new_configuration, metadata);
seq_paxos.reconfigure(rc).expect(&quot;Failed to propose reconfiguration&quot;);
</code></pre>
<p>Calling <code>reconfigure()</code> will propose a <code>StopSign</code> entry to be appended. If it gets decided, the log is sealed and prevented from being further appended. From the <code>StopSign</code> entry, all nodes will be able to see the new configuration. When you, the user, read from a node and finds a <code>LogEntry::StopSign</code> in the log, you should start a new <code>SequencePaxos</code> instance at this node if it is also part of the new configuration.</p>
<pre><code class="language-rust edition2018 no_run noplaypen">let idx: u64 = ...  // some index we last read from
    let decided_entries: Option&lt;Vec&lt;LogEntry&lt;KeyValue, KVSnapshot&gt;&gt;&gt; = seq_paxos.read_decided_suffix(idx);
    if let Some(de) = decided_entries {
        for d in de {
            match d {
                LogEntry::StopSign(stopsign) =&gt; {
                    let new_configuration = stopsign.nodes;
                    if new_configuration.contains(&amp;my_pid) {
                    // we are in new configuration, start new instance
                        let mut new_sp_conf = SequencePaxosConfig::default();
                        new_sp_conf.set_configuration_id(stopsign.config_id);
                        let new_storage = MemoryStorage::default();
                        let mut new_sp = SequencePaxos::with(new_sp_conf, new_storage);
                        
                        ... // use new_sp
                    }
                }
                _ =&gt; {
                    todo!()
                }
            }
        }
    }
</code></pre>
<blockquote>
<p><strong>Note:</strong> New nodes will not see the <code>StopSign</code> since they were not part of the old configuration. The user themselves must notify and start these new nodes. Furthermore,the user must ensure these new nodes have the application state or log up to the stopsign before starting their <code>SequencePaxos</code> instance.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logging"><a class="header" href="#logging">Logging</a></h1>
<p>OmniPaxos uses the <a href="https://crates.io/crates/slog">slog</a> crate to provide system-wide logging facilities. Logging works out of the box with a default asynchronous console and file logger implementation.</p>
<p>The actual logging levels are controlled via build features. The default features correspond to <code>max_level_trace</code> and <code>release_max_level_info</code>, that is in debug builds all levels are shown, while in the release profile only <code>info</code> and more severe message are shown.</p>
<h2 id="custom-logger"><a class="header" href="#custom-logger">Custom Logger</a></h2>
<p>Sometimes the default logging configuration is not sufficient for a particular application. For example, you might need a larger queue size in the <code>Async</code> drain, or you may want to write to a file instead of the terminal.</p>
<p>The user can provide a custom implementation based on <a href="https://crates.io/crates/slog"><strong>slog</strong></a>.</p>
<blockquote>
<p><strong>Note:</strong> This applies to <a href="sequencepaxos/../ble/index.html"><strong>Ballot Leader Election</strong></a> as well.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ballot-leader-election"><a class="header" href="#ballot-leader-election">Ballot Leader Election</a></h1>
<p>A unique feature of the Omni-Paxos protocol is guaranteed progress with one quorum-connected server using Ballot Leader Election (BLE). In this section, we will see how the leader election is used in OmniPaxos. Similar to <code>SequencePaxos</code>, <code>BallotLeaderElection</code> is represented as a Rust struct that should be started on every node in the cluster.</p>
<p>The BLE protocol is based on exchanging heartbeats that should be received within some expected time. To represent time, <code>BallotLeaderElection</code> uses an internal logical clock. It has a <code>tick()</code> function that progresses its logical clock. The expected time that heartbeats should be received in is specified by <code>hb_delay</code> of <code>BLEConfig</code> constructor:</p>
<pre><code class="language-rust edition2018 no_run noplaypen">use omnipaxos_core::ballot_leader_election::{BallotLeaderElection, BLEConfig};

/* As before, we pretend we are node 2 */
// configuration with id 1 and the following cluster
let configuration_id = 1;
let _cluster = vec![1, 2, 3];

// create the replica 2 in this cluster (other replica instances are created similarly with pid 1 and 3 on other servers)
let my_pid = 2;
let my_peers = vec![1, 3];

let mut ble_config = BLEConfig::default();
ble_config.set_pid(my_pid);
ble_config.set_peers(my_peers);
ble_config.set_hb_delay(20);     // a leader timeout of 20 ticks

let mut ble = BallotLeaderElection::with(ble_conf);
</code></pre>
<blockquote>
<p><strong>Note:</strong> The <code>priority</code> parameter allows user to give desired servers a higher priority to become the leader. This is a best-effort approach upon a leader change.</p>
</blockquote>
<p>In this example, we created our <code>BallotLeaderElection</code> with a timeout of 20 ticks. Thus, if we call <code>ble.tick()</code> every 10ms, we will in practice be using a leader timeout of 200ms. Once a leader is elected/changed, <code>tick()</code> will return a <code>Ballot</code>. This should be passed by you, the user, to the corresponding local <code>SequencePaxos</code> instance using <code>handle_leader()</code>:</p>
<pre><code class="language-rust edition2018 no_run noplaypen">let seq_paxos: SequencePaxos = ...; // create our node as in Chapter `SequencePaxos`

// every 10ms call the following
if let Some(leader) = ble.tick() {
    // a new leader is elected, pass it to SequencePaxos.
    seq_paxos.handle_leader(leader);
}
</code></pre>
<h2 id="communication-1"><a class="header" href="#communication-1">Communication</a></h2>
<p>Incoming and outgoing messages are handled in the same manner as in <code>SequencePaxos</code>. That is, the user, must fetch outgoing messages and send them over the network, and incoming messages must be passed to the <code>BallotLeaderElection</code> struct. </p>
<pre><code class="language-rust edition2018 no_run noplaypen">// handle incoming message from network layer
let ble_msg: BLEMessage = ...;    // message to this node e.g. `msg.to = 2`
ble.handle(ble_msg);

// send outgoing messages. This should be called periodically, e.g. every ms
for out_msg in ble.get_outgoings_msgs() {
    let receiver = out_msg.to;
    // send out_msg to receiver on network layer
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runtime"><a class="header" href="#runtime">Runtime</a></h1>
<p>Up to this point we have described how to work with the <code>SequencePaxos</code> and <code>BallotLeaderElection</code> structs from <code>omnipaxos_core</code>. They implement the core logic behind log replication and leader election, but require users to manually handle their interactions with each other with <code>tick()</code> and <code>handle_leader()</code> as described <a href="runtime/../ble/index.html">earlier</a>. To make it easier for users, we have prototyped a runtime called <code>omnipaxos_runtime</code> that handles this interaction with <a href="https://tokio.rs/">tokio</a>.</p>
<h2 id="creating-an-omnipaxos-node"><a class="header" href="#creating-an-omnipaxos-node">Creating an OmniPaxos node</a></h2>
<p>We will reuse the <a href="runtime/../sequencepaxos/index.html"><code>KeyValue</code></a> and <a href="runtime/../sequencepaxos/compaction.html"><code>KVSnapshot</code></a> from earlier chapters as our log entry and snapshot types. To create an <code>OmniPaxosNode</code>, we do the following:</p>
<pre><code class="language-rust edition2018 no_run noplaypen">use omnipaxos_runtime::{
    sequence_paxos::{SequencePaxos, SequencePaxosConfig},
    storage::{memory_storage::MemoryStorage},
};

let _cluster = vec![1, 2, 3];

// create node 2 in this cluster (other instances are created similarly with pid 1 and 3 on the other nodes)
let my_pid = 2;
let my_peers = vec![1, 3];

let mut node_conf = NodeConfig::default();
node_conf.set_pid(my_pid);
node_conf.set_peers(my_peers);

let storage = MemoryStorage::&lt;KeyValue, KVSnapshot&gt;::default();
let mut op: OmniPaxosHandle&lt;KeyValue, KVSnapshot&gt; = OmniPaxosNode::new(node_conf, storage);

let OmniPaxosHandle {
    omni_paxos,
    seq_paxos_handle,
    ble_handle
} = op;
</code></pre>
<p>The <code>OmniPaxosHandle</code> has three fields with the types: <code>OmniPaxosNode</code>, <code>SequencePaxosHandle</code>, and <code>BLEHandle</code>. <code>OmniPaxosNode</code> exposes a similar, but async API as <code>SequencePaxos</code> for <a href="runtime/../sequencepaxos/log.html">reading/writing</a>, <a href="runtime/../sequencepaxos/compaction.html">compaction</a>, and <a href="runtime/../sequencepaxos/reconfiguration.html">reconfiguration</a>. The <code>SequencePaxosHandle</code>, and <code>BLEHandle</code> are used for communication. We will now go through how you should be using each of these.</p>
<h2 id="communication-2"><a class="header" href="#communication-2">Communication</a></h2>
<p>Both the <code>SequencePaxosHandle</code>, and <code>BLEHandle</code> consist of two <a href="https://docs.rs/tokio/latest/tokio/sync/mpsc/index.html">tokio mpsc channels</a> each, one for incoming and one for outgoing messages. The user’s task is to read messages from the outgoing channel and send them out over the network, and push any received message from the network layer into the incoming channel. As an example, we will use tokio to spawn a separate thread for each of these tasks:</p>
<pre><code class="language-rust edition2018 no_run noplaypen">let mut sp_in: mpsc::Sender&lt;Message&lt;KeyValue, KVSnapshot&gt;&gt; = seq_paxos_handle.incoming; 
let mut sp_out: mpsc::Receiver&lt;Message&lt;KeyValue, KVSnapshot&gt;&gt; = seq_paxos_handle.outgoing; 

let mut ble_in: mpsc::Sender&lt;BLEMessage&gt; = ble_handle.incoming;
let mut ble_out: mpsc::Receiver&lt;BLEMessage&gt; = ble_handle.outgoing;

tokio::spawn(async move {
    // spawn thread to wait for any outgoing messages produced by SequencePaxos
    while let Some(message) = sp_out.recv().await {
        let receiver = message.to;
        // send Sequence Paxos message over network to the receiver
    }
});

tokio::spawn(async move {
    // spawn thread to wait for any outgoing messages produced by BallotLeaderElection
    while let Some(message) = ble_out.recv().await {
        let receiver = message.to;
        // send BLE message over network to the receiver
    }
});

tokio::spawn(async move {
    // spawn thread to wait for any incoming Sequence Paxos messages from the network layer
    loop {
        // pass message to SequencePaxos
        let sp_msg = todo!(); // received message from network layer;
        sp_in.send(sp_msg).await.expect(&quot;Failed to pass message to SequencePaxos&quot;);
    }
});

tokio::spawn(async move {
    // spawn thread to wait for any incoming BLE messages from the network layer
    loop {
        // pass message to BLE
        let ble_msg = todo!(); // received message from network layer;
        ble_in.send(ble_msg).await.expect(&quot;Failed to pass message to BallotLeaderElection&quot;);
    }
});
</code></pre>
<p>We leave the logic for receiving messages over the network as <code>todo!()</code>, since this depends on your, the user’s, network implementation.</p>
<h2 id="log-interactions"><a class="header" href="#log-interactions">Log Interactions</a></h2>
<p>Using the <code>OmniPaxosNode</code>, we will be able to call the functions of <code>SequencePaxos</code> but in an async manner. With the code below, we show how to perform the corresponding functionalities described in the <a href="runtime/../sequencepaxos/index.html">SequencePaxos</a> chapter.</p>
<pre><code class="language-rust edition2018 no_run noplaypen">let _leader_pid = omni_paxos.get_current_leader().await;

let write_entry = KeyValue {
    key: String::from(&quot;a&quot;),
    value: 123,
};
omni_paxos.append(write_entry).await.expect(&quot;Failed to append log&quot;);

let _entries: Vec&lt;ReadEntry&lt;KeyValue, KVSnapshot&gt;&gt; = omni_paxos.read_entries(10..).await.expect(&quot;Failed to read entries&quot;);
let _decided_entries: Vec&lt;ReadEntry&lt;KeyValue, KVSnapshot&gt;&gt; = omni_paxos.read_decided_suffix(0).await.expect(&quot;Failed to read decided suffix&quot;);

let local_only = true;
omni_paxos.snapshot(Some(100), local_only).await.expect(&quot;Failed to snapshot&quot;);

/* Reconfiguration */
// Node 3 seems to have crashed... let's replace it with node 4.
let new_configuration = vec![1, 2, 4];
let metadata = None;
let rc = ReconfigurationRequest::with(new_configuration, metadata);
omni_paxos
    .reconfigure(rc)
    .await
    .expect(&quot;Failed to propose reconfiguration&quot;);
</code></pre>
<p>Here, we blocked on every call, but since the functions in <code>OmniPaxosNode</code> are async, it is also possible to spawn a thread for each and wait for them concurrently.</p>
<blockquote>
<p><strong>Note:</strong> The async functions in <code>OmniPaxosNode</code> currently returns when its local Sequence Paxos component has received the request. This implies that requests that require network communication is completed. e.g. when <code>append()</code> returns, it does NOT mean that the entry has been successfully decided yet. This functionality is planned to be added in the future.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project-info"><a class="header" href="#project-info">Project Info</a></h1>
<p>While OmniPaxos is primarily being developed at the <a href="https://www.kth.se/en">KTH Royal Institute of Technology</a> and <a href="https://www.ri.se/en">RISE Research Institutes of Sweden</a> in Stockholm, Sweden, we do wish to thank all <a href="https://github.com/haraldng/omnipaxos/graphs/contributors">contributors</a>.</p>
<!-- ## Releases

OmniPaxos releases are hosted on [crates.io](https://crates.io/crates/omnipaxos). -->
<!-- ## API Documentation

OmniPaxos API docs are hosted on [docs.rs](https://docs.rs/kompact/latest/kompact/). -->
<h2 id="sources--issues"><a class="header" href="#sources--issues">Sources &amp; Issues</a></h2>
<p>The sources for OmniPaxos can be found on <a href="https://github.com/haraldng/omnipaxos">Github</a>.</p>
<p>All issues and requests related to OmniPaxos should be posted there.</p>
<h2 id="bleeding-edge"><a class="header" href="#bleeding-edge">Bleeding Edge</a></h2>
<p>This tutorial is built off the <code>master</code> branch on GitHub and thus tends to be a bit ahead of what is available in a release.
If you would like to try out new features before they are released, you can add the following to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">omnipaxos = { git = &quot;https://github.com/haraldng/omnipaxos&quot;, branch = &quot;master&quot; }
</code></pre>
<h3 id="documentation"><a class="header" href="#documentation">Documentation</a></h3>
<p>If you need the API docs for the latest master run the following at an appropriate location (e.g., outside another local git repository):</p>
<pre><code class="language-bash">git checkout https://github.com/haraldng/omnipaxos
cd omnipaxos
cargo doc --open --no-deps
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
                
    </body>
</html>
